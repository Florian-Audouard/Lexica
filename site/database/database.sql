CREATE EXTENSION IF NOT EXISTS fuzzystrmatch;
CREATE EXTENSION IF NOT EXISTS pg_trgm;

DROP TABLE IF EXISTS data CASCADE;
DROP TABLE IF EXISTS langue CASCADE;
DROP TABLE IF EXISTS livre CASCADE;
DROP TABLE IF EXISTS langue_dans_un_livre CASCADE;


CREATE TABLE livre(
    id_livre int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nom_livre text
);
CREATE TABLE langue(
    id_langue int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nom_langue text
);

CREATE TABLE langue_dans_un_livre(
    id_livre int REFERENCES livre(id_livre),
    id_langue int REFERENCES langue(id_langue),
    PRIMARY KEY(id_livre,id_langue)
);

CREATE TABLE data(
    id_data int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_langue int REFERENCES langue(id_langue),
    sens int,
    date_creation TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    traduction text,
    numero_page int,
    id_livre int
);
DROP FUNCTION IF EXISTS get_id_langue;
CREATE OR REPLACE FUNCTION get_id_langue(l langue.nom_langue%TYPE)
    RETURNS SETOF langue.id_langue%TYPE AS
    $$
        SELECT id_langue FROM langue WHERE nom_langue = l
    $$
    LANGUAGE SQL
    STABLE;

DROP FUNCTION IF EXISTS get_id_livre;
CREATE OR REPLACE FUNCTION get_id_livre(l livre.nom_livre%TYPE)
    RETURNS SETOF livre.id_livre%TYPE AS
    $$
        SELECT id_livre FROM livre WHERE nom_livre = l
    $$
    LANGUAGE SQL
    STABLE;

DROP FUNCTION IF EXISTS query_engine;
CREATE OR REPLACE FUNCTION query_engine(keyword data.traduction%TYPE, langue_base langue.nom_langue%TYPE, offset_num int)
    RETURNS TABLE(
        sens int
    )
    LANGUAGE plpgsql AS
    $query_engine$
    BEGIN
        RETURN QUERY
        SELECT id_data FROM data INNER JOIN (SELECT data.sens,data.id_langue,max(data.date_creation) FROM data
                                WHERE data.sens IN (SELECT DISTINCT data.sens FROM data
                                                        WHERE to_tsvector(data.traduction) @@ to_tsquery(keyword)
                                                        AND id_langue=(select get_id_langue(langue_base))
                                                        ORDER BY data.sens
                                                        LIMIT 25
                                                        OFFSET offset_num) GROUP BY data.sens,data.id_langue) as tmp 
                                                        on data.sens=tmp.sens and data.id_langue=tmp.id_langue and data.date_creation = tmp.max;
    END
    $query_engine$;



DROP FUNCTION IF EXISTS search;
CREATE OR REPLACE FUNCTION search(keyword data.traduction%TYPE, langue_target langue.nom_langue%TYPE, langue_base langue.nom_langue%TYPE, offset_num int)
    RETURNS TABLE(
        nom_langue text,
        traduction text,
        sens int,
        numeroPage int,
        nom_livre text
    )
    LANGUAGE plpgsql AS
    $funcSearch$
    BEGIN
        if langue_target = 'all' then
            RETURN QUERY
            SELECT langue.nom_langue,data.traduction,data.sens,data.numero_page , livre.nom_livre
                            FROM data JOIN livre ON data.id_livre = livre.id_livre
                            JOIN langue ON data.id_langue = langue.id_langue
                            WHERE data.id_data IN (select * from query_engine(keyword,langue_base,offset_num)) ORDER BY data.sens;
        else
        RETURN QUERY
            SELECT langue.nom_langue,data.traduction,data.sens,data.numero_page , livre.nom_livre
                            FROM data JOIN livre ON data.id_livre = livre.id_livre  
                            JOIN langue ON data.id_langue = langue.id_langue 
                            WHERE (data.id_langue=(select get_id_langue(langue_base))
                                    OR data.id_langue=(select get_id_langue(langue_target)))
                            AND data.id_data IN (select * from query_engine(keyword,langue_base,offset_num)) ORDER BY data.sens;    
        end if;
        END
    $funcSearch$;


DROP FUNCTION IF EXISTS page_engine;
CREATE OR REPLACE FUNCTION page_engine(num_page int , livre livre.nom_livre%TYPE)
    RETURNS TABLE(
        sens int
    )
    LANGUAGE plpgsql AS
    $query_engine$
    BEGIN
        RETURN QUERY
        SELECT id_data FROM data INNER JOIN (SELECT data.sens,data.id_langue,max(data.date_creation) FROM data
                                WHERE data.sens IN (SELECT DISTINCT data.sens FROM data
                                                        WHERE data.numero_page = num_page and data.id_livre = (SELECT get_id_livre(livre))
                                                        ORDER BY data.sens) GROUP BY data.sens,data.id_langue) as tmp 
                                                        on data.sens=tmp.sens and data.id_langue=tmp.id_langue and data.date_creation = tmp.max;
    END
    $query_engine$;

DROP FUNCTION IF EXISTS search_by_page;
CREATE OR REPLACE FUNCTION search_by_page(page int, livre livre.nom_livre%TYPE)
    RETURNS TABLE(
        nom_langue text,
        traduction text,
        sens int
    )
    LANGUAGE plpgsql AS
    $funcSearch$
    BEGIN
        RETURN QUERY
        SELECT langue.nom_langue,data.traduction,data.sens
                        FROM data JOIN langue ON data.id_langue = langue.id_langue
                        WHERE data.id_data IN (select * from page_engine(page,livre)) ORDER BY data.sens;   
        END
    $funcSearch$;
-- SELECT langue.nom, data.sens, data.mots, data.numeroPage, data.date_creation
-- FROM data JOIN langue ON (data.langue = langue.id);


DROP VIEW IF EXISTS data_current ;
CREATE OR REPLACE VIEW data_current AS (
SELECT nom_langue,data.traduction,data.sens,data.numero_page,data.id_data,langue.id_langue
FROM data JOIN langue ON data.id_langue = langue.id_langue
WHERE data.date_creation IN (
    SELECT max(data.date_creation) AS id
    FROM data
    GROUP BY id_langue, sens)
);